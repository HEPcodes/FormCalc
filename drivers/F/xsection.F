* xsection.F
* routines to compute the cross-section
* this file is part of FormCalc
* last modified 6 Oct 19 th

#include "decl.h"
#include "inline.h"
#include "contains.h"

#include "process.h"

#include "partonic.h"
#include KIN

#include "model.F"

#if PHOTONRADIATION == SOFT || GLUONRADIATION == SOFT
#include "softradiation.F"
#endif

#if PHOTONRADIATION == HARD || GLUONRADIATION == HARD
#if LEGS != 3
#error "Hard radiation not available for LEGS != 3"
#endif
#include "hardradiation.F"
#endif

#include "cuts.F"


************************************************************************
** ProcessIni translates the polarization string into bit-encoded
** helicities and initializes the model defaults.

	subroutine ProcessIni(fail, pol,
     &    sqrtSfrom, sqrtSto, sqrtSstep,
     &    argc, argv)
#ifdef SAMURAI
	use msamurai
#endif
	implicit none
	integer fail, argc
	character*(*) pol
	character*128 argv(*)
	RealType sqrtSfrom, sqrtSto, sqrtSstep

#include "xsection.h"

#if U77EXT
#define len_trim lnblnk
	integer lnblnk
	external lnblnk
#endif

	integer i, c, bits

	if( len_trim(pol) /= LEGS ) then
	  fail = 1
	  return
	endif

	helmask = 0
	do i = 1, LEGS
	  c = ior(ichar(pol(i:i)), 32)
	  if( c == ichar('u') ) then
	    bits = 16+8+4+2+1
	  else if( c == ichar('t') ) then
	    bits = 16+8+2+1
	  else if( c == ichar('p') ) then
	    bits = 16
	  else if( c == ichar('+') ) then
	    bits = 8
	  else if( c == ichar('l') ) then
	    bits = 4
	  else if( c == ichar('-') ) then
	    bits = 2
	  else if( c == ichar('m') ) then
	    bits = 1
	  else
	    Error(fail, "Invalid polarization for leg "/ /Digit(i))
	    return
	  endif
	  pol(i:i) = char(c)
	  helmask = helmask*32 + bits
	enddo

	Lower(SQRTS) = sqrtSfrom
	Upper(SQRTS) = sqrtSto
	Step(SQRTS) = sqrtSstep

	Var(FIXED) = 0
	Step(FIXED) = 1

	Var(TRIVIAL) = 0
	Step(TRIVIAL) = 0

	sqrtS = -1
	fscale = -1
	sqrtSinvalid = 1

	call ltini

#ifdef CUTTOOLS
* args are:
* 1. limitvalue = precision limit above which the mp routines are activated
* 2. scaloop = scalar integrals (1: LoopTools)
	rootsvalue = sqrtSfrom
	call ctsinit(1D-2, 1)
#endif

#ifdef SAMURAI
* args are:
* 1. imeth = "diag" (numerators) or "tree" (products of tree amps)
* 2. isca = scalar integrals (1: QCDloop, 2: OneLOop, 4: LoopTools)
* 3. verbosity = 0, 1, 2, 3
* 4. itest = 0 (none), 1 (powertest), 2 (nntest), 3 (lnntest)
	call initsamurai("diag", 4, 3, 1)
#endif

#ifdef NINJA
c	call NinjaFormCalcSetVerbosity(3)
c	call NinjaFormCalcDebug(1)
#endif

	call ModelDefaults(argc, argv)
	call LumiDefaults(argc, argv)

	fail = 0
	end


************************************************************************
** ProcessExi wraps up the calculation, e.g. prints a summary of
** messages, deallocates arrays etc.

	subroutine ProcessExi
#ifdef SAMURAI
	use msamurai
#endif
	implicit none

#ifdef SAMURAI
	call exitsamurai
#endif

	call ltexi
	end


************************************************************************
** ParameterScan performs the actual calculation.
** It scans over the parameter loops LOOP* declared in run.F.

	subroutine ParameterScan(dir,
     &    serialfrom, serialto, serialstep)
	implicit none
	character*(*) dir
	integer serialfrom, serialto, serialstep

#include "xsection.h"

	integer openlog
	external openlog

	integer next

	next = serialfrom
	serial = 0

#ifdef LOOP1
	LOOP1
#endif
#ifdef LOOP2
	LOOP2
#endif
#ifdef LOOP3
	LOOP3
#endif
#ifdef LOOP4
	LOOP4
#endif
#ifdef LOOP5
	LOOP5
#endif
#ifdef LOOP6
	LOOP6
#endif
#ifdef LOOP7
	LOOP7
#endif
#ifdef LOOP8
	LOOP8
#endif
#ifdef LOOP9
	LOOP9
#endif
#ifdef LOOP10
	LOOP10
#endif
#ifdef LOOP11
	LOOP11
#endif
#ifdef LOOP12
	LOOP12
#endif
#ifdef LOOP13
	LOOP13
#endif
#ifdef LOOP14
	LOOP14
#endif
#ifdef LOOP15
	LOOP15
#endif
#ifdef LOOP16
	LOOP16
#endif
#ifdef LOOP17
	LOOP17
#endif
#ifdef LOOP18
	LOOP18
#endif
#ifdef LOOP19
	LOOP19
#endif
#ifdef LOOP20
	LOOP20
#endif

	serial = serial + 1
	if( serial < next ) goto 1

	call flush(6)
	if( openlog(dir, serial) == 0 ) then
	  call IterateXS
	  call flush(6)
	  call closelog
	endif

	next = next + serialstep
	if( next > serialto ) return

1	continue
	end


************************************************************************
** Iterate TotalXS over kinematic loops "do Var = Lower, Upper, Step"

	subroutine IterateXS
	implicit none

#include "xsection.h"

	integer fail, f, v, c, ndim
	integer nshow, nfixed, ishow(nvars), ifixed(nvars)
	RealType res(NCOMP), err(NCOMP), show(nvars)

#define CPdecl
#include "partonic.h"
#undef CPdecl

	INFO "code generated by ", FCVERSION

	call ModelConstIni(fail)
	if( fail /= 0 ) goto 999

	flags = 2**BIT_RESET
#if NCOMP > 1
     &    + 2**BIT_LOOP
#endif

	call KinIni(fail)
	if( fail /= 0 ) goto 999

	threshold = 1D300

#define PartonicIni(sqme) call LumiIni(fail, sqme)
#define CPini
#include "partonic.h"
#undef CPini

	call ModelDigest

#define SHOW print 100,
100	format("|# ", A, "=", F10.4, SP, F10.4, " I")

#ifdef MMA
	call MmaBeginPara(serial)
#endif

#ifdef PRINT1
	PRINT1
#endif
#ifdef PRINT2
	PRINT2
#endif
#ifdef PRINT3
	PRINT3
#endif
#ifdef PRINT4
	PRINT4
#endif
#ifdef PRINT5
	PRINT5
#endif
#ifdef PRINT6
	PRINT6
#endif
#ifdef PRINT7
	PRINT7
#endif
#ifdef PRINT8
	PRINT8
#endif
#ifdef PRINT9
	PRINT9
#endif
#ifdef PRINT10
	PRINT10
#endif
#ifdef PRINT11
	PRINT11
#endif
#ifdef PRINT12
	PRINT12
#endif
#ifdef PRINT13
	PRINT13
#endif
#ifdef PRINT14
	PRINT14
#endif
#ifdef PRINT15
	PRINT15
#endif
#ifdef PRINT16
	PRINT16
#endif
#ifdef PRINT17
	PRINT17
#endif
#ifdef PRINT18
	PRINT18
#endif
#ifdef PRINT19
	PRINT19
#endif
#ifdef PRINT20
	PRINT20
#endif

#ifdef MMA
	call MmaEndPara
#endif

	nshow = 0
	nfixed = 0
	do v = MINVAR, MAXVAR
	  if( Step(v) /= 0 ) then
	    nshow = nshow + 1
	    ishow(nshow) = v
	    if( Step(v) /= -999 ) then
	      nfixed = nfixed + 1
	      ifixed(nfixed) = v
	      Var(v) = Lower(v)
	    endif
	  endif
	enddo

	ndim = nvars - nshow

1	call TotalXS(res, err, ndim)
	show(1:nshow) = Show(ishow(1:nshow))

#ifdef MMA
	call MmaData(show, nshow, res, err, NCOMP)
#else
* Note: "real" data lines are tagged with "|" in the output.
101	format("| ", 10(4G19.10, :, /"|+"))
	print 101, show(1:nshow)

102	format("|+   ", NCOMP G24.15)
	print 102, res, err

	call flush(6)
#endif

	do f = nfixed, 1, -1
	  v = ifixed(f)
	  Var(v) = Var(v) + Step(v)
	  if( (Var(v) - Upper(v))/Step(v) < eps_sqrtS ) goto 1
	  Var(v) = Lower(v)
	enddo

#ifndef MMA
103	format("|"/"|"/)
	print 103
#endif

999	continue
	end


************************************************************************
** TotalXS computes the total cross-section at one point in parameter
** space.  The cross-section is differential in all variables with 
** non-zero step, i.e. integration variables have step = 0.

	subroutine TotalXS(res, err, ndim)
	implicit none
	RealType res(NCOMP), err(NCOMP)
	integer ndim

#define CPdecl
#include "partonic.h"
#undef CPdecl

	res = 0
	err = 0

#if JOIN_PARTONIC
#define PartonicXS(sqme) call IntegrateXS(res, err, sqme, ndim)
#define CPxs
#include "partonic.h"
#undef CPxs
#else
* SQUAREDME_FUNC is a dummy here, used only because it is
* suitably declared so as not to give a compiler warning
	call IntegrateXS(res, err, SQUAREDME_FUNC, ndim)
#endif

	err = sqrt(err)
	end


************************************************************************
** IntegrateXS is a chooser for the Cuba routines, with special cases
** for ndim = 0 (integrand evaluation) and ndim = 1 (non-Cuba
** integration).

	subroutine IntegrateXS(res, err, sqme, ndim)
	implicit none
	RealType res(NCOMP), err(NCOMP)
	external sqme
	integer ndim

#include "xsection.h"

	RealType res1(NCOMP), err1(NCOMP), prob1(NCOMP)
	integer nregions, neval, fail, c

	integer novec
	parameter (novec = 1)

	integer DifferentialXS
	external DifferentialXS

#define FLAGS_LAST 4
#define FLAGS_PSEUDO 8

	if( ndim == 0 ) then

	  c = DifferentialXS(0, res1, NCOMP, res1, sqme)
	  err1 = 0
	  goto 1

	else if( ndim == 1 ) then

#if METHOD == GAUSS
	  neval = 32
	  call Gauss(NCOMP, 0D0, 1D0, DifferentialXS, sqme,
     &      neval, res1)
	  err1 = 0
	  fail = 0
	  INFO "Gauss integration results:"
#else
	  call Patterson(NCOMP, 0D0, 1D0, DifferentialXS, sqme,
     &      Re(RELACCURACY), Re(ABSACCURACY),
     &      neval, fail, res1, err1)
	  nregions = 1
	  INFO "Patterson integration results:"
#endif
	  nregions = 1
	  prob1 = -1

	else

#if METHOD == VEGAS
	  call vegas(ndim, NCOMP, DifferentialXS, sqme, novec,
     &      Re(RELACCURACY), Re(ABSACCURACY),
     &      VERBOSE, SEED, MINEVAL, MAXEVAL,
     &      NSTART, NINCREASE, NBATCH,
     &      GRIDNO, STATEFILE, SPIN,
     &      neval, fail, res1, err1, prob1)
	  nregions = 1
	  INFO "Vegas integration results:"
#elif METHOD == SUAVE
	  call suave(ndim, NCOMP, DifferentialXS, sqme, novec,
     &      Re(RELACCURACY), Re(ABSACCURACY),
     &      VERBOSE + FLAGS_LAST, SEED, MINEVAL, MAXEVAL,
     &      NNEW, NMIN, Re(FLATNESS), STATEFILE, SPIN,
     &      nregions, neval, fail, res1, err1, prob1)
	  INFO "Suave integration results:"
#elif METHOD == DIVONNE
	  call divonne(ndim, NCOMP, DifferentialXS, sqme, novec,
     &      Re(RELACCURACY), Re(ABSACCURACY),
     &      VERBOSE, SEED, MINEVAL, MAXEVAL,
     &      KEY1, KEY2, KEY3, MAXPASS,
     &      Re(BORDER), Re(MAXCHISQ), Re(MINDEVIATION),
     &      0, NDIM, 0, 0, 0, STATEFILE, SPIN,
     &      nregions, neval, fail, res1, err1, prob1)
	  INFO "Divonne integration results:"
#else
	  call cuhre(ndim, NCOMP, DifferentialXS, sqme, novec,
     &      Re(RELACCURACY), Re(ABSACCURACY),
     &      VERBOSE, MINEVAL, MAXEVAL,
     &      KEY, STATEFILE, SPIN,
     &      nregions, neval, fail, res1, err1, prob1)
	  INFO "Cuhre integration results:"
#endif

	endif

	INFO "nregions =", nregions
	INFO "neval    =", neval
	INFO "fail     =", fail

	if( fail > 0 ) then
	  Warning("Failed to reach the desired accuracy")
	else if( fail < 0 ) then
	  Error(fail, "Integration error")
	endif

100	format(I2, G24.15, " +- ", G24.15, "    p = ", F6.3)
	print 100, (c, res1(c), err1(c), prob1(c), c = 1, NCOMP)

1	res = res + res1
	err = err + err1**2
	end


************************************************************************
** DifferentialXS computes the differential cross-section at x.
** For all integration variables (those with zero step) it factors in
** the Jacobian, too.

	integer function DifferentialXS(ndim, x, ncomp, xs, sqme)
	implicit none
	integer ndim, ncomp
	RealType x(ndim), xs(ncomp)
	external sqme

#include "xsection.h"

	RealType jac, span
	integer v, d, c

#define CPdecl
#include "partonic.h"
#undef CPdecl

	DifferentialXS = 0

	jac = 1
	d = 0
	do v = MINVAR, MAXVAR
	  if( Step(v) == 0 ) then
	    span = Upper(v) - Lower(v)
	    d = d + 1
	    Var(v) = Lower(v) + x(d)*span
	    jac = jac*span
	  endif
	  Show(v) = Var(v)
	enddo

	xs = 0

#if JOIN_PARTONIC
	call EvaluateXS(xs, sqme)
#else
#define PartonicXS(sqme) call EvaluateXS(xs, sqme)
#define CPxs
#include "partonic.h"
#undef CPxs
#endif

	xs = xs*jac
	end


************************************************************************

	subroutine EvaluateXS(xs, sqme)
	implicit none
	RealType xs(*)
	external sqme

#include "xsection.h"

	RealType res(NCOMP), fac, rad, flux
	integer c, spin_df
	integer*8 helicities

#if PHOTONRADIATION == SOFT
	RealType weight1(LEGS,LEGS)
	integer sizeof_weight1
	parameter (sizeof_weight1 = LEGS*LEGS)
	data weight1 /sizeof_weight1*1/
#endif

#include "inline.h"

	fac = avgfac

	call Luminosity(fac, sqme)
	if( fac == 0 ) return

	call Kinematics(fac)
	if( fac == 0 ) return

	call Cuts(fac)
	if( fac == 0 ) return

	if( btest(flags, BIT_RESET) ) then
	  call clearcache
#ifdef RenConst_h
	  call RenConst
#endif
	endif

	helicities = helmask
	call sqme(res, helicities, flags)

	spin_df = BitCount(ibits(helicities, (LEGS-1)*ldQH, ldQH))
#if LEGS_IN == 2
     &           *BitCount(ibits(helicities, (LEGS-2)*ldQH, ldQH))
#endif

	flags = ibclr(flags, BIT_RESET)

#ifdef WF_RENORMALIZATION
	res(2) = res(2) + Re(WF_RENORMALIZATION)*res(1)
#endif

#if PHOTONRADIATION == SOFT
	call SoftRadiationFactor(rad, charge(1,pid), weight1)
	res(2) = res(2) - 2/(2*pi)**2*Alfa*rad*res(1)
#endif

#if GLUONRADIATION == SOFT
	call SoftRadiationFactor(rad, colorcharge(1,pid), weight1)
	res(2) = res(2) - 2/(2*pi)**2*Alfas*rad*res(1)
#endif

#if LEGS_IN == 1
	flux = 2*sqrtS
#else
	flux = 4/hbar_c2*sqrtS*momspec(SPEC_K,1)
#endif
	fac = fac/((2*pi)**(3*LEGS_OUT - 4)*2*spin_df*sqrtS*flux)

	do c = 1, NCOMP
	  if( .not. abs(res(c)) < 1D16 ) then
	    Warning("Got strange values from SquaredME:")
	    INFO res
	    INFO "(Did you compute the colour matrix elements?)"
	    stop
	  endif
	  xs(c) = xs(c) + fac*res(c)
	enddo
	end


************************************************************************
** SetEnergy sets the energy for the partonic scattering process.
** All scale-dependent quantities are initialized at FSCALE.

	subroutine SetEnergy(fail, newsqrtS, sqme)
	implicit none
	integer fail
	RealType newsqrtS
	external sqme

#include "xsection.h"

	RealType oldfscale, oldmass_in, oldmass_out
	logical reset
	integer i

	fail = 0

	call sqme(mass, 0, 2**BIT_SETMASS)

	reset = abs(newsqrtS - sqrtS) > eps_sqrtS
	sqrtS = newsqrtS
	oldfscale = max(Re(FSCALE), 1D0)

	if( sqrtSinvalid == 1 .or.
     &      btest(flags, BIT_RESET) .or.
     &      abs(oldfscale - fscale) > eps_sqrtS ) then
	  oldmass_in = MASS_IN
	  oldmass_out = MASS_OUT

	  do i = 1, 10
	    call ModelVarIni(fail, oldfscale)
	    call sqme(mass, 0, 2**BIT_SETMASS)
	    mass_in = MASS_IN
	    mass_out = MASS_OUT
	    fscale = max(Re(FSCALE), 1D0)

	    if( abs(fscale - oldfscale) +
     &          abs(mass_in - oldmass_in) +
     &          abs(mass_out - oldmass_out) < eps_sqrtS ) goto 1

	    oldfscale = fscale
	    oldmass_in = mass_in
	    oldmass_out = mass_out
	  enddo

1	  continue

#ifdef MUDIM
	  call setmudim(Re(MUDIM))
#endif
#ifdef DELTA
	  call setdelta(Re(DELTA))
#endif
#ifdef LAMBDA
	  call setlambda(Re(LAMBDA))
#endif
	  Divergence = getdelta()
	  mudim = getmudim()
	  muscale = mudim
	  lambda = getlambda()
	  epsi = getepsi()

#ifdef MassShift_h
	  call MassShift
	  call sqme(mass, 0, 2**BIT_SETMASS)
	  mass_in = MASS_IN
	  mass_out = MASS_OUT
	  fscale = max(Re(FSCALE), 1D0)
#endif

	  threshold = min(threshold, max(mass_in, mass_out))
	  sqrtSinvalid = fail
	  reset = .TRUE.
	endif

	if( reset ) flags = ibset(flags, BIT_RESET)
	end


************************************************************************
** fcsamurai is the FormCalc wrapper for Samurai
** it is placed here so that util.a can be built without requiring
** the .mod files of Samurai

#ifdef SAMURAI
	subroutine fcsamurai(num, numeps, nleg, rank, kj, mj, res)
	use msamurai
	use options
	implicit none
	ComplexType num, numeps, res
	external num, numeps
	integer nleg, rank
	RealType kj(nleg,4), mj(nleg)

#include "decl.h"

	ComplexType tot(-2:0), totr
	integer isca_save
	logical ok

	call samurai(num, tot, totr, kj, mj, nleg, rank, 1, mudim, ok)
	res = tot(-epsi)
	if( epsi == 0 ) then
	  isca_save = isca
	  isca = 5
	  call samurai(numeps, tot, totr, kj, mj, nleg, rank,
     &      1, mudim, ok)
	  res = res - 2*tot(-1)
	  isca = isca_save
	endif
	end
#endif

